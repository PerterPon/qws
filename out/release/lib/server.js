// Generated by CoffeeScript 1.6.3
var EventEmitter, Message, Server, crypto, os, urlParse,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Message = require('./message').Message;

EventEmitter = require('events').EventEmitter;

urlParse = require('url').parse;

crypto = require('crypto');

os = require('options-stream');

Server = (function(_super) {
  __extends(Server, _super);

  function Server(server, options, cb) {
    var _this = this;
    this.server = server;
    this.serverConfigList = [];
    this.addServer(options, cb);
    server.on('upgrade', function(req, socket) {
      var config, e, msg, num, path, result, _i, _len, _ref;
      if (true !== (result = _this._handShake(req, socket))) {
        socket.end("HTTP/1.1 400 Bad Request\r\n\r\n" + result + "\r\n");
        return;
      }
      try {
        msg = new Message(socket, {
          deflate: false
        });
      } catch (_error) {
        e = _error;
        throw e;
      }
      path = urlParse(req.url).path;
      num = _this.serverConfigList.length;
      _ref = _this.serverConfigList;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        config = _ref[_i];
        if (path === config.url) {
          if (true !== (result = _this._domainCheck(req, config))) {
            msg.write("HTTP/1.1 403 Forbidden\r\n\r\n" + result + "\r\n");
            msg.close();
            return;
          }
          msg.options = os(msg.options, config);
          msg.__QWS_CB = config.__cb;
          break;
        } else if (0 === --num) {
          msg.write('HTTP/1.1 400 Bad Request\r\n\r\nurl not matched\r\n');
          msg.close();
          return;
        }
      }
      _this.emit('connect', msg);
    });
  }

  Server.prototype.addServer = function(options, cb) {
    return this.serverConfigList.push(os({
      url: '/ws',
      deflate: false,
      min_deflate_length: 32,
      origins: [],
      __cb: cb
    }, options));
  };

  Server.prototype._handShake = function(req, socket) {
    var head, key, sha1, sign, uinfo;
    uinfo = urlParse(req.url);
    if (uinfo.protocol && uinfo.protocol !== 'ws:') {
      return 'protocol not match';
    }
    if ('websocket' !== req.headers.upgrade) {
      return 'upgrade not match';
    }
    if ('13' !== req.headers['sec-websocket-version']) {
      return 'version not match';
    }
    if (!req.headers['sec-websocket-key']) {
      return 'key missed';
    }
    key = req.headers['sec-websocket-key'];
    sha1 = crypto.createHash('sha1');
    sha1.update(key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');
    sign = sha1.digest('base64');
    head = "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: " + sign + "\r\nSec-WebSocket-Extensions: x-webkit-deflate-frame\r\nSec-WebSocket-Origin: " + req.headers.origin + "\r\nSec-WebSocket-Location: ws://" + (req.headers.host + req.url) + "\r\n\r\n";
    socket.write(head);
    return true;
  };

  Server.prototype._domainCheck = function(req, config) {
    var flag, host, origin, origins, _i, _len;
    origins = config.origins;
    host = urlParse(req.headers.origin).host;
    flag = false;
    if (host !== req.headers.host) {
      for (_i = 0, _len = origins.length; _i < _len; _i++) {
        origin = origins[_i];
        if (origin.replace(/\/$/, '') === req.headers.origin) {
          flag = true;
          break;
        }
      }
      if (!flag) {
        return "Origin " + req.headers.origin + " is not allowed";
      }
    }
    return true;
  };

  return Server;

})(EventEmitter);

exports.Server = Server;
